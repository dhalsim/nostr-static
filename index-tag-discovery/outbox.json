{"naddr1qq2j6ezsgu69j7n92cmxxmfsgyeyyvjtxfuk7qgkwaehxw309aex2mrp0yh8qunfd4skctnwv46qygrwvjurc8m8f7cq5hces9kzj7myzjlk0uq4398qfh2vv4lfgypwaqpsgqqqw4rsklwcek":{"kind":30023,"id":"e053bd17c3e36ea81d69ae382aefedf0f53188fc4f95e67b21ce35a38dc9a1e2","pubkey":"6e64b83c1f674fb00a5f19816c297b6414bf67f015894e04dd4c657e94102ee8","created_at":1745439814,"tags":[["client","Yakihonne","31990:20986fb83e775d96d188ca5c9df10ce6d613e0eb7e5768a0f0b12b37cdac21b3:1700732875747"],["published_at","1745183349"],["d","-dPG4YzeV6cm0A2B2K2yo"],["image","https://image.nostr.build/f708db07b85c002b20b3159b48447d51cbcb0bae0f5717ce6dbc060580c8b35d.jpg"],["title","How to Run Your Own Nostr Relay on Android with Cloudflare Domain"],["summary","Step-by-step guide to running a personal Nostr relay on Android using Citrine and Cloudflare Tunnels. Learn how to set up secure WebSocket connections, manage relay lists, and maintain a reliable private relay with your custom domain."],["zap","6e64b83c1f674fb00a5f19816c297b6414bf67f015894e04dd4c657e94102ee8","","100"],["t","nostr"],["t","relay"],["t","citrine"],["t","cloudflare"],["t","tunnel"],["t","outbox"],["p","6e64b83c1f674fb00a5f19816c297b6414bf67f015894e04dd4c657e94102ee8","","mention"]],"content":"# How to Run Your Own Nostr Relay on Android with Cloudflare Domain\n\n## Prerequisites\n1. Install Citrine on your Android device:\n   - Visit https://github.com/greenart7c3/Citrine/releases\n   - Download the latest release using:\n     - zap.store\n     - Obtainium\n     - F-Droid\n     - Or download the APK directly\n   - **Note:** You may need to enable \"Install from Unknown Sources\" in your Android settings\n\n2. Domain Requirements:\n   - Purchase a domain if you don't have one\n   - Transfer your domain to Cloudflare if it's not already there (for free SSL certificates and cloudflared support)\n\n3. Tools to use:\n   - nak (the nostr army knife):\n     - Download from https://github.com/fiatjaf/nak/releases\n     - Installation steps:\n       - For Linux/macOS:\n         ```bash\n         # Download the appropriate version for your system\n         wget https://github.com/fiatjaf/nak/releases/latest/download/nak-linux-amd64  # for Linux\n         # or\n         wget https://github.com/fiatjaf/nak/releases/latest/download/nak-darwin-amd64  # for macOS\n         \n         # Make it executable\n         chmod +x nak-*\n         \n         # Move to a directory in your PATH\n         sudo mv nak-* /usr/local/bin/nak\n         ```\n       - For Windows:\n         ```batch\n         # Download the Windows version\n         curl -L -o nak.exe https://github.com/fiatjaf/nak/releases/latest/download/nak-windows-amd64.exe\n         \n         # Move to a directory in your PATH (e.g., C:\\Windows)\n         move nak.exe C:\\Windows\\nak.exe\n         ```\n     - Verify installation:\n       ```bash\n       nak --version\n       ```\n\n## Setting Up Citrine\n1. Open the Citrine app\n2. Start the server\n3. You'll see it running on `ws://127.0.0.1:4869` (local network only)\n4. Go to settings and paste your npub into \"Accept events signed by\" inbox and press the + button. This prevents others from publishing events to your personal relay.\n\n## Installing Required Tools\n1. Install Termux from Google Play Store\n2. Open Termux and run:\n\n```bash\npkg update \u0026\u0026 pkg install wget\nwget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64.deb\ndpkg -i cloudflared-linux-arm64.deb\n```\n\n## Cloudflare Authentication\n1. Run the authentication command:\n```bash\ncloudflared tunnel login\n```\n2. Follow the instructions:\n   - Copy the provided URL to your browser\n   - Log in to your Cloudflare account\n   - If the URL expires, copy it again after logging in\n\n## Creating the Tunnel\n1. Create a new tunnel:\n```bash\ncloudflared tunnel create \u003cTUNNEL_NAME\u003e\n```\n   - Choose any name you prefer for your tunnel\n   - Copy the tunnel ID after creating the tunnel\n\n2. Create and configure the tunnel config:\n```bash\ntouch ~/.cloudflared/config.yml\nnano ~/.cloudflared/config.yml\n```\n\n3. Add this configuration (replace the placeholders with your values):\n```yaml\ntunnel: \u003cTUNNEL_UUID\u003e\ncredentials-file: /data/data/com.termux/files/home/.cloudflared/\u003cTUNNEL_UUID\u003e.json\ningress:\n  - hostname: nostr.yourdomain.com\n    service: ws://localhost:4869\n  - service: http_status:404\n```\n   - **Note:** In nano editor:\n     - `CTRL+O` and Enter to save\n     - `CTRL+X` to exit\n   - **Note:** Check the credentials file path in the logs\n\n4. Validate your configuration:\n```bash\ncloudflared tunnel validate\n```\n\n5. Start the tunnel:\n```bash\ncloudflared tunnel run my-relay\n```\n\n## Preventing Android from Killing the Tunnel\nRun these commands to maintain tunnel stability:\n```bash\ndate \u0026\u0026 apt install termux-tools \u0026\u0026 termux-setup-storage \u0026\u0026 termux-wake-lock\necho \"nameserver 1.1.1.1\" \u003e $PREFIX/etc/resolv.conf\n```\n\n**Tip:** You can open multiple Termux sessions by swiping from the left edge of the screen while keeping your tunnel process running.\n\n## Updating Your Outbox Model Relays\n\nOnce your relay is running and accessible via your domain, you'll want to update your relay list in the Nostr network. This ensures other clients know about your relay and can connect to it.\n\n### Decoding npub (Public Key)\n\nPrivate keys (nsec) and public keys (npub) are encoded in bech32 format, which includes:\n- A prefix (like nsec1, npub1 etc.)\n- The encoded data\n- A checksum\n\nThis format makes keys:\n- Easy to distinguish\n- Hard to copy incorrectly\n\nHowever, most tools require these keys in hexadecimal (hex) format.\n\nTo decode an npub string to its hex format:\n\n```bash\nnak decode nostr:npub1dejts0qlva8mqzjlrxqkc2tmvs2t7elszky5upxaf3jha9qs9m5q605uc4\n```\n\nChange it with your own npub.\n\n```bash\n{\n  \"pubkey\": \"6e64b83c1f674fb00a5f19816c297b6414bf67f015894e04dd4c657e94102ee8\"\n}\n```\n\nCopy the pubkey value in quotes.\n\n### Create a kind 10002 event with your relay list:\n\n- Include your new relay with write permissions\n- Include other relays you want to read from and write to, omit 3rd parameter to make it both read and write\n\nExample format:\n\n```json\n{\n  \"kind\": 10002,\n  \"tags\": [\n    [\"r\", \"wss://your-relay-domain.com\", \"write\"],\n    [\"r\", \"wss://eden.nostr.land/\"],\n    [\"r\", \"wss://nos.lol/\"],\n    [\"r\", \"wss://nostr.bitcoiner.social/\"],\n    [\"r\", \"wss://nostr.mom/\"],\n    [\"r\", \"wss://relay.primal.net/\"],\n    [\"r\", \"wss://nostr.wine/\", \"read\"],\n    [\"r\", \"wss://relay.damus.io/\"],\n    [\"r\", \"wss://relay.nostr.band/\"],\n    [\"r\", \"wss://relay.snort.social/\"]\n  ],\n  \"content\": \"\"\n}\n```\n\nSave it to a file called `event.json`\n\n**Note:** Add or remove any relays you want. To check your existing 10002 relays:\n  - Visit https://nostr.band/?q=by%3Anpub1dejts0qlva8mqzjlrxqkc2tmvs2t7elszky5upxaf3jha9qs9m5q605uc4+++kind%3A10002\n  - nostr.band is an indexing service, it probably has your relay list.\n  - Replace `npub1xxx` in the URL with your own npub\n  - Click \"VIEW JSON\" from the menu to see the raw event\n  - Or use the `nak` tool if you know the relays\n    ```bash\n    nak req -k 10002 -a \u003cyour-pubkey\u003e wss://relay1.com wss://relay2.com\n    ```\n\n    Replace `\u003cyour-pubkey\u003e` with your public key in hex format (you can get it using `nak decode \u003cyour-npub\u003e`)\n\n2. Sign and publish the event:\n   - Use a Nostr client that supports kind 10002 events\n   - Or use the `nak` command-line tool:\n   ```bash\n   nak event --sec ncryptsec1... wss://relay1.com wss://relay2.com $(cat event.json)\n   ```\n\n**Important Security Notes:**\n1. Never share your nsec (private key) with anyone\n2. Consider using NIP-49 encrypted keys for better security\n3. Never paste your nsec or private key into the terminal. The command will be saved in your shell history, exposing your private key. To clear the command history:\n   - For bash: use `history -c`\n   - For zsh: use `fc -W` to write history to file, then `fc -p` to read it back\n   - Or manually edit your shell history file (e.g., `~/.zsh_history` or `~/.bash_history`)\n4. if you're using `zsh`, use `fc -p` to prevent the next command from being saved to history\n5. Or temporarily disable history before running sensitive commands:\n\n```bash\nunset HISTFILE\nnak key encrypt ...\nset HISTFILE\n```\n\n## How to securely create NIP-49 encypted private key\n\n```bash\n# Read your private key (input will be hidden)\nread -s SECRET \n# Read your password (input will be hidden)\nread -s PASSWORD\n# encrypt command\necho \"$SECRET\" | nak key encrypt \"$PASSWORD\"\n# copy and paste the ncryptsec1 text from the output\nread -s ENCRYPTED\nnak key decrypt \"$ENCRYPTED\"\n# clear variables from memory\nunset SECRET PASSWORD ENCRYPTED\n```\n\nOn a Windows command line, to read from stdin and use the variables in `nak` commands, you can use a combination of `set /p` to read input and then use those variables in your command. Here's an example:\n\n```bash\n@echo off\nset /p \"SECRET=Enter your secret key: \"\nset /p \"PASSWORD=Enter your password: \"\n\necho %SECRET%| nak key encrypt %PASSWORD%\n\n:: Clear the sensitive variables\nset \"SECRET=\"\nset \"PASSWORD=\"\n```\n\nIf your key starts with `ncryptsec1`, the `nak` tool will securely prompt you for a password when using the `--sec` parameter, unless the command is used with a pipe `\u003c \u003e` or `|`. \n\n```bash\nnak event --sec ncryptsec1... wss://relay1.com wss://relay2.com $(cat event.json)\n```\n\n3. Verify the event was published:\n   - Check if your relay list is visible on other relays\n   - Use the `nak` tool to fetch your kind 10002 events:\n```bash\nnak req -k 10002 -a \u003cyour-pubkey\u003e wss://relay1.com wss://relay2.com\n```\n\n4. Testing your relay:\n   - Try connecting to your relay using different Nostr clients\n   - Verify you can both read from and write to your relay\n   - Check if events are being properly stored and retrieved\n   - **Tip:** Use multiple Nostr clients to test different aspects of your relay\n\n**Note:** If anyone in the community has a more efficient method of doing things like updating outbox relays, please share your insights in the comments. Your expertise would be greatly appreciated!\n","sig":"abd9291f7bc17a6d396b33f5a5f8f2dd7e8c6c1fe81b41ef7c28b2132c0af012e2686e453304e78f8d9875b34dd4d6257e475b7debfd39af983cff578144a21c"},"naddr1qq2nskt2w9vx6dznfdvj64rpw4mk5nmxf3v9xqgkwaehxw309aex2mrp0yh8qunfd4skctnwv46qygyhcu9ygdn2v56uz3dnx0uh865xmlwz675emfsccsxxguz6mx8rygpsgqqqw4rswgzyfp":{"kind":30023,"id":"efb7cad4259dec8f0403367ed4198d12aa1be35cbc59d79c7be7bcbf24eb07ef","pubkey":"97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322","created_at":1724892627,"tags":[["client","Yakihonne","31990:20986fb83e775d96d188ca5c9df10ce6d613e0eb7e5768a0f0b12b37cdac21b3:1700732875747"],["published_at","1724892627"],["d","8YjqXm4SKY-TauwjOfLXS"],["image","https://yakihonne.s3.ap-east-1.amazonaws.com/97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322/files/1724892627307-YAKIHONNES3.jpg"],["title","What is the Outbox Model?"],["summary","An explainer on the Outbox Model, including what it is, where it came from, and why it's integral to making nostr work."],["zap","97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322","","100"],["t","nostr"],["t","outbox"],["t","relays"],["t","coracle"]],"content":"Nostr is a mess. It always has been and will always be. That's part of the appeal! But it's important that users be able to navigate the rolling seas of this highly partition-tolerant network of kaleidoscopically-interwoven people, bots, topics, relays, clients, events, recommendations, lists, feeds, micro-apps, macro-apps, Chinese spam, and \"GM\"s.\n\nIn order to do this, users must be able to articulate \"what\" they are looking for, and clients must be able to articulate \"how\" to find that thing. This \"how\" is divided into two parts: building a request that will match the desired content (very easy), and selecting a relay that is able to serve that content to the user requesting it (very very hard).\n\n# Why guessing isn't good enough\n\nAs a concrete example, let's say the user wants to find everyone in their \"network\" who is using a particular topic. The process would look something like this:\n\n1. The user clicks the \"network\" tab and types in the topic they want to browse. This is the \"what\".\n2. The client then translates the term \"network\" to a list of public keys using whatever definition they prefer (Follows? WoT? Grapevine?), and builds a filter that might look something like this: `[{\"authors\": pubkeys, \"#t\": [\"mytopic\"]}]`. Any relay will happily accept, understand, and respond to that filter.\n3. The client then has to decide which relays it should send that filter to. This is the `???` stage of the outbox model, which immediately precedes:\n4. Profit\n\nIt may not be immediately obvious why selecting the correct relays might be difficult. Most people post to relay.damus.io, and most people read from relay.damus.io, so in most cases you should be good, right?\n\nThis approach to relay selection has historically worked \"well enough\", but it depends on a flawed definition of success. If you only want to find 90% of the content that matches your query, using the top 10 relays will suffice. But nostr is intended to be censorship-resistant. What if those 10 hubs have banned a particular public key? Nostr clients should (at least in theory) be 100% successful in retrieving requested content. Even if someone only posts to their self-hosted relay, you should be able to find their notes if their account is set up properly.\n\n# A naive solution to fixing the FOMO\n\nA 90% hit rate results in a feeling of flakiness, even if users aren't completely aware of what isn't working. Feeds will be incomplete, quoted notes will be missing, replies will be orphaned, user profiles won't load. The natural response to the FOMO this creates is for users to \"try harder\" by adding more relays.\n\nOn the read side, this means clients open more connections, resulting in much higher data transfer requirements, with massively diminishing returns, since there's no reason to expect that a randomly chosen relay will have a substantially different data set.\n\nOne the publish side, this means that clients end up publishing more copies of their data to more relays. This approach has been automated in the past by services like Blastr, which don't store a copy of events published to the relay, but instead forward events to the top 300 relays in the network. This results in a two-orders-of-magnitude increase in storage required, and only makes the read side of the problem worse, since it reduces the uniqueness of the data set each relay stores. This in turn means that more duplicates are retrieved when querying relays.\n\nBoth halves of this approach are equivalent to guessing. On the read side, users are guessing which relays will have any arbitrary content they might ask for in the future. On the write side, users are guessing which relays other people might use to find their notes. It is a brute-force method for finding content.\n# Randomness results in centralization\n\nIn theory, random relay selection would result in a perfect distribution of content across all relays in the network. But in practice, this method of selection isn't random at all, but is strongly influenced by user bias in what constitutes a \"good\" relay. While some users may check [nostr.watch](https://nostr.watch) for ping times, geographical proximity, or uptime, most will choose relays based on familiar names or other people's recommendations.\n\nIn either case, these biases are entirely orthogonal to achieving a higher content retrieval hit rate, _except when bias in relay selection results in clustering_ — i.e., centralization. In other words, the kind of randomness exhibited by users when selecting relays actually results in pretty much everyone picking the same few relays. We see this same effect when people try to come up with passwords or seed phrases — human-provided randomness is anything but random.\n\nClustering improves the hit rate when requesting events (slightly), but it results in nearly as much centralization as if only a single relay was used — and a lot more duplicate events.\n# Something (anything) other than randomness\n\nIn early 2023, Mike Dilger [introduced NIP 65](https://github.com/nostr-protocol/nips/pull/218) (now known as the \"Outbox Model\") with a problem statement in the spirit of the original description of nostr: \"Nostr should scale better. People should be able to find what they want.\"\n\n_Historical note: NIP 65 was formerly known as the \"Gossip Model\", derived from the name of Mike's [desktop nostr client](https://github.com/mikedilger/gossip), called \"Gossip\". This unfortunately created a lot of confusion, since [gossip protocols](https://en.wikipedia.org/wiki/Gossip_protocol) work very differently from how nostr tends to work, hence the re-brand._\n\nBefore NIP 65, an informal standard existed in which `kind 3` user contact lists also included a list of relays that clients could use as something similar to Mastodon's \"home servers\". This list included the option to only read or write from a given relay. Unfortunately, it wasn't really clear what the semantics of this relay list were, so different clients handled them differently (and many clients ignored them). Usually this amounted to user-provided static relay configurations, which resulted in the naive relay selection approach described above.\n\nNIP 65 used a very similar format (a list of relay urls with optional \"read\" or \"write\" directives), but with a very important semantic difference: relays listed in a user's `kind 10002` were intended to \"advertise to others, not for configuring one's client.\" In other words, these relay selections were intended as a signal to other users that they should use certain relays when attempting to communicate with the author of the relay list.\n\nI highly recommend reading the [entire NIP](https://github.com/nostr-protocol/nips/blob/master/65.md), which is very short and easy to read. But the mechanics of the spec are very simple:\n\n\u003e When seeking events **from** a user, Clients SHOULD use the WRITE relays of the user's `kind:10002`.\n\u003e\n\u003e When seeking events **about** a user, where the user was tagged, Clients SHOULD use the READ relays of the user's `kind:10002`.\n\u003e\n\u003e When broadcasting an event, Clients SHOULD:\n\u003e\n\u003e - Broadcast the event to the WRITE relays of the author\n\u003e - Broadcast the event to all READ relays of each tagged user\n\nFor the first time, we had a way to differentiate relays in terms of _what content could be found where_.\n\nWhen looking for a note by a particular user, a client could now look up the author's `write` relays according to their `kind 10002` event, and send its query there. The result is a much higher hit rate with much lower data transfer requirements, and fewer connections per query.\n# Making Outbox Work\n\nThere are of course some assumptions required to make this work. \n\nFirst, the user must know which author they're looking for. This isn't always true when looking up a quote or parent note, but context and [pubkey hints](https://github.com/nostr-protocol/nips/pull/1171) solve this difficulty in most cases.\n\nThe author must also publish a `kind 10002` event. This may not always be the case, but clients should prompt users to set up their relay list correctly. This isn't really a flaw in the Outbox Model, just in implementations of it.\n\nAdditionally, the user's client must be able to find the author's `kind 10002` event. This is the \"bootstrapping\" phase of the Outbox Model, during which the mechanisms the system provides for finding events aren't available. This requires us to fall back to randomly guessing which relays have the content we're looking for, which as we saw above doesn't work very well.\n\nOther than guessing, there are a few different ways a client might find the relay selection event in question, each of which is applicable in different circumstances. In most cases, using one of a handful of indexer relays like [purplepag.es](wss://purplepag.es) or [relay.nostr.band](wss://relay.nostr.band) is a simple and efficient way to find user profiles and relay selections.\n\nHowever, if an author's content has been aggressively purged from these indexers due to censorship, they obviously can't be relied upon. Even though the author in question hasn't been deplatformed from nostr itself (since he can always self-host a publicly accessible relay to store his content), he has been effectively shadow-banned.\n\nTo get around this, relay selections have to be communicated in some other way. Nostr has a few different mechanisms for this:\n\n- If the author's NIP 05 address is known and properly configured (it may not be), clients can look up the author's NIP 05 endpoint to find some reasonable relay hints. Unfortunately, these are often neglected, and usually custodial, so they can run into the same problems.\n- If the author's pubkey is found in another signed event found on nostr, [relay hints](https://github.com/nostr-protocol/nips/blob/fade0164f52033314bf0a5ef9bd63c2483afae9b/10.md#marked-e-tags-preferred) can be a way to propagate relay selections through the network. This relies on implementations picking reliable relay hints which can be difficult, and hints do tend to become less reliable over time. However, this strategy is very effective in resisting censorship because it makes banning viral — if a relay wants to completely purge a particular pubkey from their database, they have to purge every event that references it, since events are tamper-proof.\n- In extremis, relay recommendations can always be communicated out-of-band. This can be done using manual input, QR codes, DHTs, jsonl torrents full of `kind 10002` events, or any other mechanism client developers choose to resort to.\n\nAnother, more technical assumption is that any given query can be fulfilled by few enough relays that a client can actually make all the connections needed, without running into resource limits. If you're trying to request content from 10,000 users across 1,000 relays, you're going to have a bad time. This was [pointed out](https://coracle.social/nevent1qythwumn8ghj76twvfhhstnwdaehgu3wwa5kuef0qyv8wumn8ghj7cm9d3kxzu3wdehhxarj9emkjmn99uq3samnwvaz7tmrwfjkzarj9ehx7um5wgh8w6twv5hsqgrn7l6zj7ht6ruyk76vvvtkfs4xrhyzc3tm64l3eyfvd40y26sz0gshmunh) to me by Mazin of [nostr.wine](https://nostr.wine). He makes a good point, and it's definitely something to keep in mind. There are some mitigating factors though.\n\nThe first is that the current topology of the network probably won't persist forever. Because nostr is largely populated by self-hosting enthusiasts, the number of \"tiny\" relays is proportionally much higher than it will be if adoption picks up, even if the total number of relays grows. The trajectory is that nostr will drift toward fewer, larger relays, reducing the number of connections needed to fulfill any given query.\n\nThis is \"centralizing\", but it's important to understand that this isn't necessarily a bad thing. As long as there are more than one or two large hubs, there is user choice. And as long as it's possible to run a new relay, there is always an escape hatch. Nostr, like bitcoin, has no hard dependency on the biggest player in the network.\n\nThe other thing to consider is that there are lots of other techniques we can use to overcome the limits of the lowest-common denominator's limitations (mobile browser clients), including self hosted or third-party relay proxies. The trade-off here is that a little trust (aka centralization) can go a long way to reducing resource requirements needed to fulfill queries using the Outbox model.\n\nIf you're interested in more details on this topic, see [this blog post](https://habla.news/u/hodlbod@coracle.social/sfwV1rNaoQXd65PbIMYgm).\n\nThat was a long digression, but there is one other thing that the Outbox model assumes to be the case. Even if the correct relays are found and connected to, they still may not return all desired content, either because they don't have it, or because they refuse to return it to the user requesting it.\n\nThis can happen if the publishing client isn't following the Outbox Model, if the author had migrated from one relay set to another without copying their notes over, or if the relay in question chose not to retain the author's content for some reason.\n\nThe first two issues can be fixed by improving implementations, but the question of policy is a little more interesting.\n# Relativistic relays\n\nThe Outbox Model is a mechanical process; it's only as useful as user relay selections are. In order for it to work, users have to be able to make intelligent relay selections.\n\nEvery relay has trade-offs, depending on its policy. [140.f7z.io](wss://140.f7z.io) would not be useful for long-form content, for example. Some relays might have a content retention policy that changes depending on whether you're a paying user. If you don't pay, you might find out too late that your content has been deleted from the relay.\n\nSo what makes a relay \"good\" for a particular use case? Well, it's complicated. Here are a few factors that go into that calculus:\n\n- Is the relay in the same geographical as the user? Proximity reduces latency, but jurisdictional arbitrage might be desired. Users should probably have a variety of relays that fit different profiles.\n- Will the relay ban the user? Do the operators have a history of good behavior? Is the relay focused on particular types of content? Is the relay's focus consistent with the user's goal in adding that relay to their list?\n- What are the relay's retention policies? A user might want to set up an archival relay for her old content, or a multi-availability-zone relay so her notes are immediately accessible to the rest of the network.\n- Does the relay require payment? Paid relays are more aligned with their users, but obviously come at a financial cost.\n- Does the relay have policies for read-protecting content? If so, other users might not be able to find your posts published to that relay. On the other hand, some relays are configured to work as inboxes for direct messages, which can help preserve privacy.\n- Does the relay request that users authenticate? Authentication can help manage spam, but it also allows relays to correlate content requests with users, reducing user privacy.\n- Is the relay you use hosted by your client's developer? If so, you're in danger of getting banned from your client and your relay at the same time.\n- Is the relay a hub? Using hubs can help smooth out rough areas in Outbox Model implementations, at the cost of centralization.\n- Is the relay used by anyone else? One-off relays can be useful for archival purposes, but often won't be used by clients following the Outbox Model, depending on how they optimize requests.\n\nThere are lots of ways to approach the problem of helping users select relays, but it's an inherently complex problem which very few people will have the patience to properly address on their own. Relay selection is a multi-dimensional problem, and requires satisfying multiple constraints with a limited number of relay selections.\n\nIn the future, special-purpose clients might be used to help people build relay sets. Clients also might provide curated \"relay kits\" that users can choose and customize. Or, we might see an increase in hybrid solutions, like smarter relay proxies or client-local relays that synchronize using other protocols or platforms.\n# The Limitations of Outbox\n\nOutbox is not a complete solution, not because of any of the caveats listed above, but because NIP 65 per se only addresses the question of how to index content by pubkey in a broadcast social media context. But there are many other scenarios for relay selection that Outbox does not solve:\n\n- Community, chat, and group posts might be best posted to relays dedicated to that context.\n- Direct messages shouldn't follow the same contours as public social media content.\n- Topic-oriented relays, or relays serving a custom feed might be useful independent of who uses them.\n- Relays focused on serving a particular kind of event, like music, long-form content, or relay selections, are useful independent of who reads from or writes to them.\n- Certain clients might need to fulfill particular use cases by using relays that support certain protocol features, like search, count, or sync commands.\n- Some events might not make sense to publish to relays, but should instead be shared only directly, out of band.\n\nSome of these use cases might be solved by new specifications similar to Outbox that prescribe where certain data belongs — for example, [NIP 17](https://github.com/nostr-protocol/nips/blob/master/17.md) requires users to publish a different relay list before they can receive direct messages, while [NIP 72](https://github.com/nostr-protocol/nips/blob/master/72.md) places community relay recommendations directly into the group's metadata object. A reasonably complete list of different relay types can be found in [this PR](https://github.com/nostr-protocol/nips/issues/1282), very few of which have a canonical way to manage selections.\n\nOther use cases might be supported more informally, either by relays advertising their own value proposition, or via third-party [NIP 66](https://github.com/nostr-protocol/nips/pull/230) metadata. Still others might be supported by scoping the network down to only certain relays through explicit relay selection — this is how white-labeled [Coracle instances](https://coracle.tools/) work.\n\nThe basic idea here is that there are categories of events that don't have anything to do with where a particular person puts his or her \"tweets\". For every \"what\" on nostr, there should be a \"how\".\n# Keep nostr weird\n\nWhatever additional systems we end up adopting for helping with relay selection, one thing is certain — people will continue to discover new, creative uses for relays, and we will always be playing catch up. This is one of the coolest things about nostr!\n\nBut it does mean that users will have to adapt their expectations to a network that partitions, re-configures, and evolves over time. Nostr is not a \"worse\" experience than legacy social media, but it is a version of social media that has itself been set free from the stagnant walled-garden model. Nostr is in many ways a living organism — we should be careful not to impose our expectations prematurely, leaving room to discover what this thing actually is, or can be.\n\nIf you enjoyed this post but want more take a look at the talk I gave at [Nostrasia](https://www.youtube.com/live/Nz15SyiwQFk?t=2751s) last year. I also wrote up a [blog post](https://habla.news/u/hodlbod@coracle.social/1700155417145) at about the same time that addresses some of the same issues, but focuses more on privacy concerns around relays and nostr groups. Finally, I recently wrote [this comment](https://github.com/nostrability/nostrability/issues/69#issuecomment-2310524841), which includes some details about challenges I've faced putting Outbox into Coracle.","sig":"384174ce37d84d535cd78dab02f04bfed7fe99a0defb3369d6984ea991fd024eb6cd8ff647c3cd56173772ec1bfead560052e7e03052a7f91d87bb6dd43ea04b"},"naddr1qqxnzde3xy6rvwpnx56rvdpkqyt8wumn8ghj7un9d3shjtnswf5k6ctv9ehx2aqzyqtnnkfhmjxqcums4gn4skfccyv7yhzp7mzyrfwnf3kns5p7xymw7qcyqqq823c4wuj34":{"kind":30023,"id":"a5eadf5e75e94e0dc61d9ccfa86cf9132cb0c7fc6cc2375ef194af5bae06de2a","pubkey":"1739d937dc8c0c7370aa27585938c119e25c41f6c441a5d34c6d38503e3136ef","created_at":1711542302,"tags":[["d","1711468354646"],["title","What is (and isn't) the \"gossip\" model?"],["summary","It's Outbox, not Gossip. A non-technical overview of how Nostr can reduce relay centralization."],["t","nostr"],["t","relays"],["t","decentralization"],["t","learn"],["t","gossip"],["t","outbox"],["t","inbox"],["image","https://i.nostr.build/nWPOo.webp"],["published_at","1711542302"],["alt","This is a long form article, you can read it in https://habla.news/a/naddr1qqxnzde3xy6rvwpnx56rvdpkqgspwwwexlwgcrrnwz4zwkze8rq3ncjug8mvgsd96dxx6wzs8ccndmcrqsqqqa28jnw7un"],["p","97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322"],["p","ee11a5dff40c19a555f41fe42b48f00e618c91225622ae37b6c2bb67b76c4e49"],["p","3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d"],["a","30023:3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d:87a208d9","wss://relay.westernbtc.com/","mention"],["p","5be6446aa8a31c11b3b453bf8dafc9b346ff328d1fa11a0fa02a1e6461f6a9b1"],["p","e1ff3bfdd4e40315959b08b4fcc8245eaa514637e1d4ec2ae166b743341be1af"],["p","79c2cae114ea28a981e7559b4fe7854a473521a8d22a66bbab9fa248eb820ff6"],["a","30023:97c70a44366a6535c145b333f973ea86dfdc2d7a99da618c40c64705ad98e322:sfwV1rNaoQXd65PbIMYgm","","mention"],["a","30023:ee11a5dff40c19a555f41fe42b48f00e618c91225622ae37b6c2bb67b76c4e49:1711144225050","","mention"]],"content":"\"Gossip\", \"Outbox\", \"Inbox\", \"Blastr\", \"Small relays vs Big relays\". You've probably seen most of these topics come up in conversations and memes recently. You might have even read nostr:nprofile1qqsf03c2gsmx5ef4c9zmxvlew04gdh7u94afnknp33qvv3c94kvwxgsm3u0w6's article (nostr:naddr1qq2hxenh2cchynnpdag4sepkx4gxyj2dt9nk6q3qjlrs53pkdfjnts29kveljul2sm0actt6n8dxrrzqcersttvcuv3qxpqqqp65wd3a9ny), or nostr:nprofile1qqswuyd9ml6qcxd92h6pleptfrcqucvvjy39vg4wx7mv9wm8kakyujgua442w's very technical article (nostr:naddr1qqxnzde3xycngdpjxg6nqdfsqgswuyd9ml6qcxd92h6pleptfrcqucvvjy39vg4wx7mv9wm8kakyujgrqsqqqa28906usv), or maybe even nostr:nprofile1qqsrhuxx8l9ex335q7he0f09aej04zpazpl0ne2cgukyawd24mayt8g2lcy6q's one with the clickbaity title (nostr:naddr1qvzqqqr4gupzqwlsccluhy6xxsr6l9a9uhhxf75g85g8a709tprjcn4e42h053vaqydhwumn8ghj7un9d3shjtnhv4ehgetjde38gcewvdhk6tcprfmhxue69uhhq7tjv9kkjepwve5kzar2v9nzucm0d5hsz9mhwden5te0wfjkccte9ehx7um5wghxyctwvshsqzpcxasnyvpcvsusgpcqx3).\n\nThese are all great, and you should go and read them too. But one thing that each of them is guilty of is assuming that the audience has enough context to jump into the middle of a very nuanced and technical discussion. I've yet to see a clear description of what Gossip or Outbox really are and certainly none that are written in a way that is approachable for a non-technical audience. I hope this article can give you that context and serve as a high-level overview of the discussion and the technologies involved so that you can go forth to create better, more informed memes (is there anything more important, really?) and join the discussion in a productive way.\n\n## The problems\n\n### Centralization is the default\n\nFirst off, why are we even talking about relays? Most of know that nostr is a protocol which is _designed_ to be decentralized from the ground up. That decentralization is due in large part to the fact that users read and write data to multiple relays by default. So instead of all your data going to a centralized database (usually owned and operated by a single company) with nostr you have the ability to send your data to as as many relays as you'd like (relays are just databases, after all). Likewise, you can read other people's data from as many relays as you'd like to. Decentralized design = decentralized system, right!? Well, turns out, no.\n\nThe problem with a design like this is that what _can_ be done and what _will_ be done are often very different things. Imagine the following scenario: You follow 1000 people; 700 of them post their notes to the Primal relay, the other 300 post their notes to the Damus relay. If you don't also write your content to those two relays, the people that you care about won't see your content, they won't see your replies to their notes, they won't even know you exist. So while; in practice, it's easy to read \u0026 write to many different relays, users and their content will tend to centralize because it's the path of least resistance to a good user experience. Network effects and economies of scale always apply, they just don't always lead to the outcomes that you want.\n\nBefore you start to panic, this sort of centralization isn't a huge issue just yet. We are still a nascent network and there are still hundreds of active relays out there. Almost all nostr clients make relay selection a first class citizen and don't default new users to a single relay. The fact that we're even having this conversation in a serious way at this stage is a great sign that the community cares enough to be proactive about maintaining (and improving) decentralization over time.\n\nThat said, this is not a issue that we can take lightly either. The top 5-10 relays do already have an outsized percentage of users and we have many examples of these centralizing tendencies across dozens of protocols and networks over the last 30 years, so the threat is real.\n\n### The status quo is wasteful\n\nThe other major issue is that currently most nostr clients are extremely wasteful in how they fetch data. The default is to simply get _everything_ from _all the relays_ a user wants to connect to. Because most of us are writing the same data to many relays, this leads to huge amounts of duplicated data being downloaded, having its signatures verified, and then (for the most part) thrown away. For those of us with latest generation smartphones, unlimited data, and a working power outlet nearby, this is fine. For everyone else, this is a major roadblock to adopting nostr.\n\n## A lightly technical aside\n\nThere are a few important features of nostr that make any sort of intelligent data fetching possible. To understand how any of the potential solutions to the aforementioned problems would actually work, it's important to have a baseline understanding of these technical details. I promise, I'll keep it high level.\n\n### Relay lists\n\nRecently the concept of a Relay List Metadata has been introduced to the spec in [NIP-65](https://github.com/nostr-protocol/nips/blob/master/65.md) (there are also other types of relay lists documented in [NIP-51](https://github.com/nostr-protocol/nips/blob/master/51.md)). This is a nostr list event where users publish their preferred relays with a marker that says whether the relay is for read-only, write-only, or read \u0026 write. This vastly simplifies the process of finding preferred user relays for clients and I imagine that this will become the de facto standard place to look for a user's preferred relays.\n\n### NIP-05\n\nThe [NIP-05](https://github.com/nostr-protocol/nips/blob/master/05.md) spec also documents a way for users to signal their preferred relays. However, unlike the NIP-65 relay list, this is a simple list of relays without any details on whether the user reads or writes to those relays.\n \n### Tag markers\n\nTag markers are positional elements in tags that give the client publishing the event the ability to leave a hint as to which relay other clients can expect to find a given user or note that is being referenced.\n\nFor example, in a user's contact list (a `kind: 3` event) you have many `\"p\"` tags to reference all the user's that are followed. These tags look like this:\n\n```\n{\n  \"kind\": 3,\n  \"tags\": [\n    [\"p\", \"91cf9..4e5ca\", \"wss://alicerelay.com/\", \"alice\"],\n    [\"p\", \"14aeb..8dad4\", \"wss://bobrelay.com/nostr\"],\n    [\"p\", \"612ae..e610f\"]\n  ],\n  \"content\": \"\",\n  ...other fields\n}\n```\n\nAll three of these `\"p\"` tags are valid (only the `\"p\"` and the user's pubkey are required), in the first and second you can see the third item is a relay where the user's events can be found.\n\nThese types of tag markers are repeated all throughout nostr. Here's a few more example references for an event (in this case a long-form article):\n\n```\n[\"e\", \"b3e392b11f5d4f28321cedd09303a748acfd0487aea5a7450b3481c60b6e4f87\", \"wss://relay.example.com\"],\n\n[\"a\", \"30023:a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919:ipsum\", \"wss://relay.nostr.org\"]\n```\n\nAs you can imagine, these hints can be very helpful but _only if_ clients actually attempt to fetch the content from the referenced relay.\n\n## The solutions?\n\nNow that you understand the problem space a bit better let's define those terms we started with.\n\n### Blastr\n\n[Blastr](https://github.com/MutinyWallet/blastr) was created by nostr:nprofile1qqs9hejyd252x8q3kw6980ud4lymx3hlx2x3lgg6p7sz58nyv8m2nvgdswkeh and nostr:nprofile1qqswrlemlh2wgqc4jkds3d8ueqj9a2j3gcm7r48v9tskdd6rxsd7rtcpwpuwc from Mutiny and **isn't** a relay. Instead, Blastr is a proxy (i.e. it looks like a relay to clients) that ingests any event sent to it and, in turn, sends those events to EVERY online relay on the network. It's a mass re-broadcaster for events that can be helpful to get your data pushed out to as many relays (and thus users) as possible. The drawback, of course, is that this is tremendously wasteful from a bandwidth and storage perspective.\n\n### Gossip (in 3 flavors)\n\nThis is _by far_ the most confusing part for most people when watching the memes of the last few weeks fly by and I've seen a lot of confused takes out there. Most of the confusion stems from the multiplicity of definitions of what the \"gossip model\" actually is. Let's go through the options.\n1. **[Gossip protocols](https://en.wikipedia.org/wiki/Gossip_protocol):** This is a general concept more than a specific implementation. Gossip protocols are protocols that attempt to spread information around a network in a uniform way. For example, Bitcoin nodes use a variation of the gossip protocol to make sure that transactions end up in as many mempools as possible. This is important in computing when you want to reach consensus or when all nodes in a network need to have the same information in order to operate the network. Since nostr doesn't have any consensus rules or shared compute, it's somewhat pointless to try and make sure all events are propagated to all relays (hence the limited usefulness of Blastr).\n2. **The [Gossip](https://github.com/mikedilger/gossip) client** from nostr:nprofile1qqswuyd9ml6qcxd92h6pleptfrcqucvvjy39vg4wx7mv9wm8kakyujgua442w : This is a nostr client that was built from the ground up to try and use relays and relay hints in events to the fullest to keep things as decentralized as possible while being efficient in how much data it was fetching. Mike has a great (slightly outdated and very technical) video that talks about his motivation behind building Gossip in the way he did. It's worth a watch. [video link](https://mikedilger.com/gossip-relay-model.mp4) \n3. **Gossip model:** This is what people are usually referring to when they are talking about relays on nostr. The Gossip model is a loose, catch-all term used to refer to all the ways in which clients attempt to understand which relays they should read \u0026 write to for a given user. Again, this isn't really a specific spec or implementation but encompasses many different strategies. This vagueness inherent in the term makes discussions about the \"gossip model\" pretty imprecise and prone to misunderstanding. \n\n### Don't gossip\n\n**To be clear:** You really shoud not be thinking about or talking about any of this as the \"gossip model\" since that definition is so abstract as to be unusable. Which brings us finally to the real topic being discussed at the moment among devs; the Outbox model.\n\n### Outbox/Inbox model\n\nThis is the _real_ topic of conversation right now: **_How should client developers build relay discovery and selection features into their apps_**. As we already talked about, if left alone, it's likely that we'd unintentionally centralize most of nostr onto a few huge relays. So making sure that we encourage (and build sensible defaults) to help client developers to treat relay discovery and selection properly is really critical.\n\nRight now, the discussion centers around one main approach, called the \"Outbox model\". There is also an \"Inbox model\" which is a still just a high level idea which I'll mention below but it's not being implemented yet (as of late March 2024).\n1. The **\"Outbox model\"**: This strategy looks at what relays users are using to publish their events (from relay lists and tag markers) and then uses an algorithm to decide how to fetch all the needed events from the array of relays. Different implementations can use different algorithms to select relays. For example, one implementation might optimize fetching events from the smallest number of relays (favoring large relays), while another might optimize for fetching from the relays that have the smallest user overlap (favoring small relays).\n2. The **\"Inbox model\"**: As you can imagine, this strategy flips the outbox model on it's head. It's so far just an [idea](https://github.com/nostr-protocol/nips/discussions/1134) (proposed by nostr:nprofile1qqs8nsk2uy2w529fs8n4tx60u7z553e4yx5dy2nxhw4elgjgawpqlas9waufq) and a [draft NIP](https://github.com/nostr-protocol/nips/pull/1135/files) but the idea is that when your client posts on your behalf, it will loop over your entire follow list, making a list of the relays that each of your followers uses to read events. Then the client will publish your event to _all_ of those relays. If all clients followed this paradigm, then each of us would only have to read from a single relay. To quote nostr:nprofile1qqs8nsk2uy2w529fs8n4tx60u7z553e4yx5dy2nxhw4elgjgawpqlas9waufq 's original post, \"This doesn't take away from the outbox approach, and maybe should even be used together instead of as a replacement. But my point is that clients should be trying harder to deliver posts instead of just fetch posts. Because it benefits users when their posts can be seen.\"\n\n## Why the Outbox model has broad support\n\nTo understand why implementing an Outbox model is so powerful at solveing the problems laid out at the beginning of this article, you can do two quick thought experiments:\n\n### A user banned from _all_ other relays\n\nImagine a user who's content is banned from all public relays for some reason. Instead, they have to run their own relay and publish their events there. With a simple \"follow the major relays model\" (or even with Blastr attempting to copy and paste their events to every other relay) this user is completely invisible to the network. User's would have to know about the banned user's private relay and select that relay in each client they use. What's more, if that relay ever had to change URL (likely for a user that is banned so broadly), all user's would need to know what the new URL is in order to change relays and fetch events from the new location.\n\nWith Outbox however, clients will see that their user's follow this user, will then look up this user's relay list, and will know where they need to go to fetch their events. It becomes much more difficult for relays to censor or block users with an Outbox model in place\n\n### Duplicate event fetching\n\nWe talked earlier about how many nostr clients often fetch the same data many times, just to throw that data away. Even using the simplest algorithms with an Outbox model, you can significantly reduce the amount of duplicate data you're fetching from relays. We, as users, would all also need to specific many fewer relays in our relay lists but would still be quite sure our clients would be able to find all the content we want to see.\n\n### Wrapping up\n\nHopefully this has given you a better overall understanding of what folks are talking about when they refer to Gossip (remember: don't refer to it this way) or Outbox (outbox, yay!) and why we need to be proactive about maintaining the decentralization of nostr.","sig":"6754f5818ae666f3055f753ee61075abc92f31cd7a8a40d5cce119e34bbceaf88c2c9b33ce91dc23eb02b26b8d4fed8350827fb94f570c4ba19268675947f114"}}